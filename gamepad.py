import RPi.GPIO as GPIO
import time
from evdev import UInput, ecodes as e

# Mapeamento dos GPIOs para os códigos de teclas
BUTTONS = {
    13: e.KEY_UP,         # Up (D-pad)
    6: e.KEY_DOWN,        # Down (D-pad)
    26: e.KEY_LEFT,       # Left (D-pad)
    5: e.KEY_RIGHT,       # Right (D-pad)
    
    0: e.KEY_ENTER,       # Círculo (Enter)
    1: e.KEY_SPACE,       # X (Espaço)
    12: e.KEY_BACKSPACE,  # Quadrado (Backspace)
    19: e.KEY_Z,          # Triângulo (Z)

    16: e.KEY_LEFTCTRL,   # L
    20: e.KEY_LEFTALT,    # R

    21: e.KEY_ESC,        # Start (Escape)
}

# Configuração dos GPIOs
GPIO.setmode(GPIO.BCM)
GPIO.setup(list(BUTTONS.keys()), GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Inicializa a emulação de entrada com evdev
ui = UInput()

def button_pressed(channel):
    if GPIO.input(channel) == GPIO.LOW:  # Verifica se o botão está realmente pressionado
        ui.write(e.EV_KEY, BUTTONS[channel], 1)
        ui.syn()

def button_released(channel):
    if GPIO.input(channel) == GPIO.HIGH:  # Verifica se o botão foi realmente liberado
        ui.write(e.EV_KEY, BUTTONS[channel], 0)
        ui.syn()

# Configura interrupções para os botões
for gpio in BUTTONS:
    GPIO.add_event_detect(gpio, GPIO.BOTH, callback=lambda channel: (button_pressed(channel), button_released(channel)), bouncetime=50)

try:
    # Loop principal continua em execução enquanto o script não for interrompido
    while True:
        time.sleep(0.1)  # Aguarda um curto período para reduzir o uso de CPU
except KeyboardInterrupt:
    pass
finally:
    GPIO.cleanup()
    ui.close()
