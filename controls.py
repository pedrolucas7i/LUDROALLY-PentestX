import RPi.GPIO as GPIO
import subprocess
import time
import os

# Definição dos pinos GPIO para as linhas e colunas da matriz de botões (3x3)
ROW_PINS = [5, 6, 13]       #  A, B, C
COL_PINS = [19, 26, 21]     #  D, E, F

# Mapeamento dos botões da matriz para suas funções
# Vamos definir que o botão do meio (linha 1, coluna 1) será o clique do mouse,
# e os botões ao redor serão usados para mover o cursor
BUTTON_FUNCTIONS = {
    (0, 0): 'left',    # Esquerda
    (0, 1): 'up',      # Cima
    (0, 2): 'right',   # Direita
    (1, 0): 'click',   # Clique do mouse (meio)
    (1, 1): 'other',   # Botão sem função definida
    (1, 2): 'other',   # Botão sem função definida
    (2, 0): 'down',    # Baixo
    (2, 1): 'other',   # Botão sem função definida
    (2, 2): 'other'    # Botão sem função definida
}

# Configuração do modo de numeração dos pinos
GPIO.setmode(GPIO.BCM)

# Configuração das linhas como saída e das colunas como entrada com resistores pull-up
for row in ROW_PINS:
    GPIO.setup(row, GPIO.OUT, initial=GPIO.LOW)  # Começa como LOW (desativada)

for col in COL_PINS:
    GPIO.setup(col, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Ativa com resistor pull-up

# Função para mover o cursor do mouse
def move_mouse(x, y):
    try:
        result = subprocess.run(["xdotool", "mousemove_relative", "--", str(x), str(y)], check=True)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Error moving mouse: {e}")
        return -1

# Função para clicar com o mouse
def click_mouse():
    try:
        result = subprocess.run(["xdotool", "click", "1"], check=True)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Error clicking mouse: {e}")
        return -1

# Função para escanear a matriz e identificar qual botão foi pressionado
def scan_matrix():
    for row_index, row_pin in enumerate(ROW_PINS):
        # Ativa a linha atual
        GPIO.output(row_pin, GPIO.HIGH)
        
        # Verifica o estado de cada coluna
        for col_index, col_pin in enumerate(COL_PINS):
            if GPIO.input(col_pin) == GPIO.LOW:  # Botão pressionado
                return (row_index, col_index)
        
        # Desativa a linha após verificar
        GPIO.output(row_pin, GPIO.LOW)
    
    return None  # Nenhum botão pressionado

# Configurações de movimento e velocidade
acceleration = 5  # Aceleração do movimento
max_speed = 20    # Velocidade máxima
x_speed = 0       # Velocidade atual no eixo X
y_speed = 0       # Velocidade atual no eixo Y

try:
    while True:
        pressed_button = scan_matrix()  # Verifica se algum botão foi pressionado
        
        if pressed_button:
            action = BUTTON_FUNCTIONS.get(pressed_button)
            
            if action == 'left':
                x_speed = -acceleration
            elif action == 'right':
                x_speed = acceleration
            elif action == 'up':
                y_speed = -acceleration
            elif action == 'down':
                y_speed = acceleration
            elif action == 'click':
                click_mouse()  # Executa um clique com o mouse

        else:
            # Se nenhum botão for pressionado, a velocidade é zerada
            x_speed = 0
            y_speed = 0
        
        # Limita a velocidade máxima
        x_speed = max(min(x_speed, max_speed), -max_speed)
        y_speed = max(min(y_speed, max_speed), -max_speed)
        
        # Move o cursor do mouse
        if x_speed != 0 or y_speed != 0:
            move_mouse(x_speed, y_speed)

        # Aguarda um curto período para ajustar a sensibilidade
        time.sleep(0.05)

except KeyboardInterrupt:
    # Limpa a configuração dos pinos GPIO ao encerrar o programa
    GPIO.cleanup()
