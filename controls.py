import RPi.GPIO as GPIO
import subprocess
import time
import os

# Definição dos pinos GPIO para as linhas e colunas da matriz de botões (4x3)
ROW_PINS = [0, 5, 6, 19]    #  A, B, C, D
COL_PINS = [26, 1, 16]      #  E, F, G

"""
1  -  AG
2  -  AF
3  -  BG
4  -  AE
5  -  BF
6  -  BE
7  -  CE
8  -  CF
9  -  DE
10 -  CG
11 -  DF
12 -  DG
"""
BUTTON_FUNCTIONS = {
    (0, 2): 'SUPER',
    (0, 1): 'LEFT',
    (1, 2): 'UP',
    (0, 0): 'DOWN',
    (1, 1): 'RIGHT',
    (1, 0): 'VOL_DOWN',
    (2, 0): 'VOL_UP',
    (2, 1): 'RIGHT_CLICK',
    (3, 0): 'LEFT_CLICK',
    (2, 2): 'COPY',
    (3, 1): 'PASTE',
    (3, 2): 'TAB'
}

# Configuração do modo de numeração dos pinos
GPIO.setmode(GPIO.BCM)

# Configuração das linhas como saída e das colunas como entrada com resistores pull-up
for row in ROW_PINS:
    GPIO.setup(row, GPIO.OUT, initial=GPIO.LOW)  # Começa como LOW (desativada)

for col in COL_PINS:
    GPIO.setup(col, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Ativa com resistor pull-up

# Função para mover o cursor do mouse
def move_mouse(x, y):
    try:
        result = subprocess.run(["xdotool", "mousemove_relative", "--", str(x), str(y)], check=True)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Error moving mouse: {e}")
        return -1

# Função para clicar com o mouse
def click_mouse():
    try:
        result = subprocess.run(["xdotool", "click", "1"], check=True)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Error clicking mouse: {e}")
        return -1
    
# Função para pressionar uma tecla
def press_key(key):
    try:
        result = subprocess.run(["xdotool", "key", key], check=True)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Error pressing key {key}: {e}")
        return -1

# Função para escanear a matriz e identificar qual botão foi pressionado
def scan_matrix():
    for row_index, row_pin in enumerate(ROW_PINS):
        # Ativa a linha atual
        GPIO.output(row_pin, GPIO.HIGH)
        
        # Verifica o estado de cada coluna
        for col_index, col_pin in enumerate(COL_PINS):
            if GPIO.input(col_pin) == GPIO.LOW:  # Botão pressionado
                return (row_index, col_index)
        
        # Desativa a linha após verificar
        GPIO.output(row_pin, GPIO.LOW)
    
    return None  # Nenhum botão pressionado

# Configurações de movimento e velocidade
acceleration = 5  # Aceleração do movimento
max_speed = 20    # Velocidade máxima
x_speed = 0       # Velocidade atual no eixo X
y_speed = 0       # Velocidade atual no eixo Y

try:
    while True:
        pressed_button = scan_matrix()  # Verifica se algum botão foi pressionado
        
        if pressed_button:
            action = BUTTON_FUNCTIONS.get(pressed_button)
            
            if action == 'LEFT':
                x_speed = -acceleration
            elif action == 'RIGHT':
                x_speed = acceleration
            elif action == 'UP':
                y_speed = -acceleration
            elif action == 'DOWN':
                y_speed = acceleration
            elif action == 'LEFT_CLICK':
                click_mouse(button=1)  # Executa um clique com o botão esquerdo
            elif action == 'RIGHT_CLICK':
                click_mouse(button=3)  # Executa um clique com o botão direito
            elif action == 'SUPER':
                press_key('Super_L')  # Pressiona a tecla Super (Windows/Command)
            elif action == 'VOL_UP':
                press_key('XF86AudioRaiseVolume')  # Aumenta o volume
            elif action == 'VOL_DOWN':
                press_key('XF86AudioLowerVolume')  # Diminui o volume
            elif action == 'COPY':
                press_key('ctrl+c')  # Copia o texto selecionado
            elif action == 'PASTE':
                press_key('ctrl+v')  # Cola o texto copiado
            elif action == 'TAB':
                press_key('Tab')  # Pressiona a tecla Tab


        else:
            # Se nenhum botão for pressionado, a velocidade é zerada
            x_speed = 0
            y_speed = 0
        
        # Limita a velocidade máxima
        x_speed = max(min(x_speed, max_speed), -max_speed)
        y_speed = max(min(y_speed, max_speed), -max_speed)
        
        # Move o cursor do mouse
        if x_speed != 0 or y_speed != 0:
            move_mouse(x_speed, y_speed)

        # Aguarda um curto período para ajustar a sensibilidade
        time.sleep(0.05)

except KeyboardInterrupt:
    # Limpa a configuração dos pinos GPIO ao encerrar o programa
    GPIO.cleanup()
