import RPi.GPIO as GPIO
import subprocess
import time

# Definição dos pinos GPIO para as linhas e colunas da matriz de botões (4x3)
ROW_PINS = [20, 5, 6, 19]   # Colunas (físicas), agora são linhas (lógicas)
COL_PINS = [26, 21, 16]  # Linhas (físicas), agora são colunas (lógicas)

# Mapeamento das funções para cada combinação de linha e coluna
BUTTON_FUNCTIONS = {
    (0, 2): 'SUPER',
    (0, 1): 'LEFT',
    (1, 2): 'UP',
    (0, 0): 'DOWN',
    (1, 1): 'RIGHT',
    (1, 0): 'VOL_DOWN',
    (2, 0): 'VOL_UP',
    (2, 1): 'RIGHT_CLICK',
    (3, 0): 'LEFT_CLICK',
    (2, 2): 'COPY',
    (3, 1): 'PASTE',
    (3, 2): 'TAB'
}

# Configuração do modo de numeração dos pinos
GPIO.setmode(GPIO.BCM)

# Configuração das linhas como saída e das colunas como entrada com resistores pull-down
for row in ROW_PINS:
    GPIO.setup(row, GPIO.OUT, initial=GPIO.LOW)

for col in COL_PINS:
    GPIO.setup(col, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# Função para mover o cursor do mouse
def move_mouse(x, y):
    try:
        subprocess.run(["xdotool", "mousemove_relative", "--", str(x), str(y)], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error moving mouse: {e}")

# Função para clicar com o mouse
def click_mouse(button=1):
    try:
        subprocess.run(["xdotool", "click", str(button)], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error clicking mouse: {e}")

# Função para pressionar uma tecla
def press_key(key):
    try:
        subprocess.run(["xdotool", "key", key], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error pressing key {key}: {e}")

# Função para escanear a matriz e identificar qual botão foi pressionado
def scan_matrix():
    for row_index, row_pin in enumerate(ROW_PINS):
        GPIO.output(row_pin, GPIO.HIGH)  # Ativa a linha atual

        # Verifica o estado de cada coluna
        if GPIO.input(COL_PINS[0]) == 1:  # Coluna 0 pressionada
            GPIO.output(row_pin, GPIO.LOW)      # Desativa a linha antes de retornar
            return (row_index, 0)  # Retorna a linha e a coluna do botão pressionado

        if GPIO.input(COL_PINS[1]) == 1:  # Coluna 1 pressionada
            GPIO.output(row_pin, GPIO.LOW)      # Desativa a linha antes de retornar
            return (row_index, 1)  # Retorna a linha e a coluna do botão pressionado

        if GPIO.input(COL_PINS[2]) == 1:  # Coluna 2 pressionada
            GPIO.output(row_pin, GPIO.LOW)      # Desativa a linha antes de retornar
            return (row_index, 2)  # Retorna a linha e a coluna do botão pressionado

        GPIO.output(row_pin, GPIO.LOW)  # Desativa a linha após verificar

    return None  # Nenhum botão foi pressionado


# Configurações de movimento e velocidade
acceleration = 5
max_speed = 20
x_speed = 0
y_speed = 0

try:
    while True:
        pressed_button = scan_matrix()
        
        if pressed_button:
            #print(f"Botão pressionado: {pressed_button}")  # Debug: Imprime a coordenada do botão
            action = BUTTON_FUNCTIONS.get(pressed_button)
            #print(f"Ação executada: {action}")  # Debug: Imprime a ação associada
            
            if action == 'LEFT':
                x_speed = -acceleration
            elif action == 'RIGHT':
                x_speed = acceleration
            elif action == 'UP':
                y_speed = -acceleration
            elif action == 'DOWN':
                y_speed = acceleration
            elif action == 'LEFT_CLICK':
                click_mouse(button=1)
            elif action == 'RIGHT_CLICK':
                click_mouse(button=3)
            elif action == 'SUPER':
                press_key('Super_L')
            elif action == 'VOL_UP':
                press_key('XF86AudioRaiseVolume')
            elif action == 'VOL_DOWN':
                press_key('XF86AudioLowerVolume')
            elif action == 'COPY':
                press_key('ctrl+shift+c')
            elif action == 'PASTE':
                press_key('ctrl+shift+v')
            elif action == 'TAB':
                press_key('Tab')

        else:
            x_speed = 0
            y_speed = 0
        
        x_speed = max(min(x_speed, max_speed), -max_speed)
        y_speed = max(min(y_speed, max_speed), -max_speed)
        
        if x_speed != 0 or y_speed != 0:
            move_mouse(x_speed, y_speed)

        time.sleep(0.05)

except KeyboardInterrupt:
    GPIO.cleanup()
